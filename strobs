#! /bin/sh
#
# Stream-Observer (strobs) is a script to observe running voc video streams.
#
# The script opens mpv with all active (currently streaming) streams from
# Chaos Computer Club made by VOC (video operation center) in a playlist
# as found at https://streaming.media.ccc.de.
# Optionally it can also try to open all streams given in a valid playlist.
#
# MIT License
# Copyright (c) 2020 Simpel

# set e: exit if something fails; set u: exit if a variable is unset
set -eu

#######################################
### Globals
#######################################

readonly serverpath="http://live.ber.c3voc.de:7999/"
readonly serversuffix="_vpx"
readonly red='\033[0;31m'
readonly yellow='\033[0;33m'
readonly nc='\033[0m' # No Color
readonly underlined='\033[4m'
readonly progname="${0##*/}"
readonly progpath="${0%/*}/"
readonly version="2.0.24"
unset conference # if set contains the name of the conference
unset debug # if set print verbose messages red to differ from debug messages
unset exitscript # if set don't open mpv; useful for debugging and json export
unset force # if set and used with option -p / -j forces open playlist / load full json
unset icecast # if set contains icecast status json
unset name_array # if set contains conferences, streams and display names
unset name_ext # if set playlist server names append technical name (e.g. s23)
unset name_json # if set containes display names of the cuurent running streams
unset print_json # if set export json to disk
unset playlist # if set use directly this playlist
unset playlist_info # if set contains Info line in mvp what stream it is
unset sort # if set servers sorted alphanumerical else as found
unset timetable # if set timetable of running and coming events is printed
verbosity=0 # if > 0 show verbose messages in levels

#######################################
### Functions
#######################################

#######################################
# Print verbose messages (in red if debug).
# Globals:
#   verbosity
#   debug
#   red
#   nc
# Arguments:
#   level
# Outputs:
#   msg to STDERR
# Returns:
#   None
#######################################
verbose() {
	msg="${1}"
	level="${2:-1}" # default 1 if not given
	i=0
  # only level up to verbosity
	if [ ${level} -le ${verbosity} ]; then
    # print '=' for every level
		while [ ${i} -lt ${level} ]; do
      # colorize in debug mode
      if [ -n "${debug-}" ]; then
        printf "${red}=${nc}\n" >&2
      else
        printf "=" >&2
      fi
			i=$(( ${i} + 1 ))
		done
    # print verbose message (colorize in debug mode)
    if [ -n "${debug-}" ]; then
  		echo "${red}> ${msg}${nc}" >&2
    else
  		echo "> ${msg}" >&2
    fi
	fi
}

#######################################
# Show extracted shortcuts from input.conf.
# Globals:
#   progpath
#		yellow
#		nc
# Arguments:
#   None
# Outputs:
#   shortcut to STDOUT
# Returns:
#   None
#######################################
keys()
{
	if [ ! -f "${progpath}input.conf" ]; then
		printf "%b\n" "${yellow}Warning: '${progpath}input.conf' with key definition does not exist${nc}" 1>&2
		exit 1
	fi
	echo "Shortcuts:"
  # grep all lines start not with #
  grep '^[[:blank:]]*[^[:blank:]#]' ${progpath}input.conf
        verbose "keys (${LINENO}): grep shortcuts from 'input.conf': $?" 2
  exit 0
}

#######################################
# Prints timetable with conferene, start and end date.
# Globals:
#   None
# Arguments:
#   api json in JSON
# Outputs:
#   startsAt \t endsAt \t conferene to STDOUT
# Returns:
#   None
#######################################
timetable_array ()
{
	verbose "timetable_array (${LINENO}): Create timetable array"
	# Catch conference, startsAt, endsAt of every stream event
	result="$(echo "$1" | grep -E "\"conference\": \"?.+\"?,|\"startsAt\": \"?.+\"?,|\"endsAt\": \"?.+\"?,")"
				verbose "timetable_array (${LINENO}): Grep 'conference, startsAt, endsAt and values': $?" 2
	# Make one plain, clean line of them all
	result="$(echo "${result}" | awk '{$1=$1;print}')"
			  verbose "timetable_array (${LINENO}): Remove leading/trailing white spaces: $?" 2
	result="$(echo "${result}" | sed 's/,$//g')"
        verbose "timetable_array (${LINENO}): Remove trailing commas: $?" 2
  result="$(echo "${result}" | tr '\n' '\t')"
        verbose "timetable_array (${LINENO}): Replace all newlines with tabs: $?" 2
  # Make every stream event a single line
  result="$(echo "${result}" | sed 's/\"conference/\'$'\n\"conference/g')"
        verbose "timetable_array (${LINENO}): Insert newlines before conference: $?" 2
  # Remove first empty line
  result="$(echo "${result}" | tail -n +2)"
        verbose "timetable_array (${LINENO}): Remove first newline: $?" 2
  # Remove all keys from key:value
	result="$(echo "${result}" | sed 's/\"conference\": //g')"
				verbose "timetable_array (${LINENO}): Remove 'conference': $?" 2
	result="$(echo "${result}" | sed 's/\"startsAt\": //g')"
				verbose "timetable_array (${LINENO}): Remove 'startsAt': $?" 2
  result="$(echo "${result}" | sed 's/\"endsAt\": //g')"
        verbose "timetable_array (${LINENO}): Remove 'endsAt': $?" 2
  result="$(echo "${result}" | sed 's/\"//g')"
        verbose "timetable_array (${LINENO}): Remove all \": $?" 2
	# Remove +0000 in timestamps
	result="$(echo "${result}" | sed 's/+0000//g')"
        verbose "timetable_array (${LINENO}): Remove '+0000': $?" 2
	# Change order and set conference last
	result="$(echo "${result}" | awk -v FS='\t' -v OFS='\t' '{print $2, $3, $1}')"
				verbose "timetable_array (${LINENO}): Change order: $?" 2
	# Return only events that are running or planned
	date="$(date -u +"%Y-%m-%dT%H:%M:%S")" # now
	result="$(echo "${result}" | awk -F '\t' -v force_date="${date}" '$2>=force_date && $2!="null" {print $0}')"
				verbose "timetable_array (${LINENO}): Strip timetable array to now"
	# Remove disturbing 'T' from UTC timestamps
	result="$(echo "${result}" | sed 's/\([0-9]\{4\}-[0-9][0-9]-[0-9][0-9]\)T\([0-9][0-9]:[0-9][0-9]:[0-9][0-9]\)/\1 \2/g')"
				verbose "timetable_array (${LINENO}): Remove 'T' from timestamps: $?" 2
	if [ -z "${result-}" ]; then
		printf "%b\n" "${yellow}Warning: no events found${nc}" 1>&2
	else
		printf "%b\n" "${yellow}starts at (UTC)\t\tends at (UTC)\t\tconference${nc}" 1>&2
		printf "%b\n" "${result}" 1>&2
	fi
}

#######################################
# Convert icecast status json to server array.
# Globals:
#   None
# Arguments:
#   icecast
# Outputs:
#   (stream \t url \n)* to STDOUT
# Returns:
#   result
#######################################
server ()
{
  verbose "server (${LINENO}): Create server array"
  # Catch http://live.ber.c3voc.de:7999/xxxx_xxxx of every stream event
  result="$(echo "$1" | grep -E -o 'http[^,]*'$serversuffix)"
        verbose "server (${LINENO}): Grep 'urls with $serversuffix including values': $?" 2
  # Remove serverpath and serversuffix
  result="$(echo "${result}" | sed 's/http:\/\/live.ber.c3voc.de:7999\///g')"
        verbose "server (${LINENO}): Remove '$serverpath': $?" 2
  result="$(echo "${result}" | sed 's/'$serversuffix'//g')"
        verbose "server (${LINENO}): Remove '$serversuffix': $?" 2
  echo "${result}"
}

#######################################
# Convert api json to names array.
# Globals:
#   None
# Arguments:
#   name_json
# Outputs:
#   ((stream \n display \n)* conference)* to STDOUT
# Returns:
#   result
#######################################
name_array ()
{
	verbose "name_array (${LINENO}): Create name array"
	# Catch all "conferences", "display" with 24spaces ahead (there are many more "display"), "stream"
	result="$(echo "$1" | grep -E '\"conference\":|^\s{24}\"display\":|\"stream\":')"
				verbose "name_array (${LINENO}): Grep 'conferences, display, streams incl. values': $?" 2
	result="$(echo "${result}" | awk '{$1=$1;print}')"
				verbose "name_array (${LINENO}): Remove leading and trailing spaces: $?" 2
	result="$(echo "${result}" | awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }')"
				verbose "name_array (${LINENO}): Reorder list upside down: $?" 2
	echo "${result}"
}

#######################################
# Returns line number where stream is found in name_array.
# Globals:
#   name_array
# Arguments:
#   STREAM
# Outputs:
#   Integer to STDOUT
# Returns:
#   result
#######################################
stream_pos ()
{
	verbose "stream_pos (${LINENO}): Return line number where stream is found"
	result="$(echo "${name_array}" | sed -n '/'$1'/=')"
				verbose "stream_pos (${LINENO}): Get position of '$1': $?" 2
	echo "${result}"
}

#######################################
# Returns display name found in name_array.
# Globals:
#   name_array
# Arguments:
#   STREAM_POS
# Outputs:
#   display to STDOUT
# Returns:
#   result
#######################################
display ()
{
	verbose "display (${LINENO}): Return display name from name_array"
	result="$(echo "${name_array}" | awk 'NR=='$1'')"
				verbose "display (${LINENO}): Print line $1: $?" 2
	result="$(echo "${result}" | sed 's/"display": "//g')"
				verbose "display (${LINENO}): Remove '\"display\":': $?" 2
	result="$(echo "${result}" | sed 's/",//g')"
				verbose "display (${LINENO}): Remove '\",': $?" 2
	echo "${result}"
}

#######################################
# Returns conference found in name_array.
# Globals:
#   name_array
# Arguments:
#   STREAM_POS
# Outputs:
#   conference to STDOUT
# Returns:
#   result
#######################################
findconference ()
{
	verbose "findconference (${LINENO}): Return conferences from name_array"
	result="$(echo "${name_array}" | awk 'NR>='$1'')"
				verbose "findconference (${LINENO}): Print lines from $1: $?" 2
	result="$(echo "${result}" | grep -m 1 "conference")"
				verbose "findconference (${LINENO}): Grep first occurence of 'conference including value': $?" 2
	result="$(echo "${result}" | sed 's/"conference": "//g')"
				verbose "findconference (${LINENO}): Remove '\"conference\":': $?" 2
	result="$(echo "${result}" | sed 's/",//g')"
				verbose "findconference (${LINENO}): Remove '\",': $?" 2
	echo "${result}"
}

#######################################
# Returning servers sorted alphanumerical.
# Globals:
#   None
# Arguments:
#   STREAMS
# Outputs:
#   sorted streams to STDOUT
# Returns:
#   None
#######################################
sort_alphanum ()
{
  verbose "sort_alphanum (${LINENO}): Sorting servers"
  # Padding numbers with zeros to make sort with leading characters work
  result="$(echo "$1" | awk '{ gsub(/([^[:digit:]]+|[[:digit:]]+)/,"&\t") ; printf("%s%05d\n", $1, $2)}')"
        verbose "sort_alphanum (${LINENO}): Fill numbers with leading zeros: $?" 2
  result="$(echo "${result}" | sort -n)"
        verbose "sort_alphanum (${LINENO}): Sort numerical: $?" 2
  # Split leading characters to remove padded zeros
  result="$(echo "${result}" | awk '{ gsub(/([^[:digit:]]+|[[:digit:]]+)/,"&\t") ; print  $1, $2}')"
        verbose "sort_alphanum (${LINENO}): Split at beginning of number: $?" 2
  result="$(echo "${result}" | awk '{gsub ("^0*", "", $2); printf("%s%s\n", $1, $2)}')"
        verbose "sort_alphanum (${LINENO}): Strip leading zeros and merge: $?" 2
  echo "${result}"
}

#######################################
# Print streaming.json, icecast-status.xsl.
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
# Returns:
#   None
#######################################
printjson ()
{
	verbose "printjson (${LINENO}): Print status_liveber.xsl, status_ingest.xsl, current.json"
	# Export icecast status to disk
	curl -sSf http://live.ber.c3voc.de:7999/status-json.xsl > status_liveber.xsl
	curl -sSf http://ingest.c3voc.de:8000/status-json.xsl > status_ingest.xsl
	# Export streaming.json to disk
	if [ -n "${force-}" ]; then
    # with option forceopen=1 (shows all streams done, running and planned)
    JSON="$(curl -sSf https://streaming.media.ccc.de/streams/v2.json?forceopen=1)"
  else
    # shows only running streams
    JSON="$(curl -sSf https://streaming.media.ccc.de/streams/v2.json)"
  fi
	echo "${JSON}" > current.json
	# Don't start mpv and avoid deleting current-playlist.m3u8
	exitscript=true
}

#######################################
# Cleanup on exit.
#   Delete current-playlist (if not exitscript).
# Globals:
#   playlist
#   exitscript
# Arguments:
#   None
# Outputs:
#   None
# Returns:
#   None
#######################################
cleanup ()
{
  verbose "cleanup (${LINENO}): Cleanup on exit" 3
	# delete current playlist
  playlist="${progpath}current-playlist.m3u8"
  if [ -e "${playlist}" ] && [ -z "${exitscript-}" ]; then
    rm "${playlist}"
          verbose "cleanup (${LINENO}): Delete 'current-playlist.m3u8': $?" 3
  fi
  exit 0
}

#######################################
# Opens man page strobs.1.
# Globals:
#   progpath
#		yellow
#		nc
# Arguments:
#   None
# Outputs:
#   None
# Returns:
#   None
#######################################
manpage()
{
	if [ ! -f "${progpath}strobs.1" ]; then
		printf "%b\n" "${yellow}Warning: man page '${progpath}strobs.1' does not exist${nc}" 1>&2
		exit 1
	fi
	man ${progpath}strobs.1
	exit 0
}

#######################################
# Prints the usage manual.
# Globals:
#   progname
#   underlined
#   nc
# Arguments:
#   None
# Outputs:
#   usage to SDTOUT
# Returns:
#   None
#######################################
manual()
{
  echo "Usage: ${progname} [ -d | -D | -f | -h | -j | -k | -m | -n | -p ${underlined}file${nc} | -s | -t | -v | -V | -x]"
  echo "       opens mpv with all active voc streams"
  echo "       -d debug mode: print commands and arguments while executed"
  echo "       -D debug mode: print script lines while read"
  echo "       -f forces (with -p / -j) open playlist / download full json"
  echo "       -h help shown"
  echo "       -j json export to disk"
  echo "       -k keys/shortcuts shown"
  echo "       -m man page shown"
  echo "       -n name stream with technical extension"
  echo "       -p playlist ${underlined}file${nc} with servers in format m3u8"
  echo "       -s sort server list alphanumerical"
  echo "       -t timetable of running and coming events shown"
  echo "       -v verbosity increasing with ${underlined}v${nc}"
  echo "       -V version print"
  echo "       -x exit before mpv, keeps current-playlist.m3u8"
  exit 0
}

#######################################
### Main
#######################################

# Check options
while getopts 'dDfhjkmnp:stvVx' option 2>/dev/null; do
  case "${option}" in
    d ) set -x # print commands and arguments while executed
        debug=true;;
    D ) set -v # print script lines while read
        debug=true;;
    f ) force=true;;
    h ) manual;;
    j ) print_json=true;;
    k ) keys;;
		m ) manpage;;
    n ) name_ext=true;;
    p ) playlist="${OPTARG}";;
    s ) sort=true;;
    t ) timetable=true
				force=true;;
    v ) verbosity=$(( ${verbosity} + 1 ));;
    V ) echo "${progname} version ${version}"
        exit 0;;
    x ) exitscript=true;;
    * ) if [ $1 != "-?" ]; then
          curropt=$(( ${OPTIND} - 1 ))
          eval "curropt=\$${curropt}"
          printf "%b\n" "${yellow}Warning: illegal option ${curropt}${nc}" 1>&2
        fi
        manual;;
  esac
done
verbose "${yellow}Note: number after colon usually represents commands exit code${nc}"
verbose "Level of verbosity: ${verbosity}"

# Exit handler
trap cleanup 0 1 2 3 6

# Check for option -j
if [ -n "${print_json-}" ]; then
	printjson
fi

# Check for option -t; print timetable of running and coming events
if [ -n "${timetable-}" ]; then
	# with option forceopen=1 (shows all streams done, running and planned)
	JSON="$(curl -sSf https://streaming.media.ccc.de/streams/v2.json?forceopen=1)"
				verbose "main (${LINENO}): Curl json for option -t: $?" 2
	# Print start date, end date and conference from $JSON
	timetable_array "${JSON}"
	exit 0
fi

# Check if mpv is existing
if ! [ -x "$(command -v mpv)" ]; then
  printf "%b\n" "${red}Error: mpv does not exist, please install${nc}" 1>&2
  printf "%b\n" "Look: https://mpv.io/installation" 1>&2
  exit 1
fi

# Choose the playlist
# Playlist given with option -p
if [ -n "${playlist-}" ]; then
        verbose "Used playlist: ${playlist}"
  if [ ! -f "${playlist}" ]; then
		if wget --spider "${playlist}" 2>/dev/null; then
				verbose "Used playlist is remote"
		else
			if [ ! -n "${force-}" ]; then
		    printf "%b\n" "${yellow}Warning: playlist '${playlist}' does not exist, but you can enforce with option -f${nc}" 1>&2
		    exit 1
			fi
		fi
  fi
else
	# Playlist should have only streams found at icecast status
	playlist="${progpath}current-playlist.m3u8"
	verbose "Used playlist: ${playlist}"

	# Catch icecast status live.ber
				verbose "main (${LINENO}): Read icecast status json"
	icecast="$(curl -sSf http://live.ber.c3voc.de:7999/status-json.xsl)"
	# Check if streaming - then "listenurl" is inside
	if [ "$(echo "${icecast}" | grep listenurl -c)" = 0 ]; then
		# Check if ingest server is receiving
		icecast="$(curl -sSf http://ingest.c3voc.de:8000/status-json.xsl)"
		if [ "$(echo "${icecast}" | grep listenurl -c)" = 0 ]; then
			printf "%b\n" "${yellow}Warning: no active streams available${nc}" 1>&2
			exit 1
		else
			printf "%b\n" "${yellow}Warning: no active streams available but ingest is active - try a bit later${nc}" 1>&2
			exit 1
		fi
	fi

	# Find streams in $icecast
	STREAMS="$(server "${icecast}")"
	verbose "Server array:\n${STREAMS}" 4
	# Exit if no servers found
	if [ "${STREAMS}" = "" ]; then
		printf "%b\n" "${yellow}Warning: no searched streams available${nc}" 1>&2
		exit 1
	fi
	# Sort servers alphanumerical
	if [ -n "${sort-}" ]; then
		STREAMS="$(sort_alphanum "${STREAMS}")"
	fi
	verbose "Extracted servers:\n${STREAMS}" 3

  # Read running streams by api json - look for matches for displayed stream name
				verbose "main (${LINENO}): Read stream json"
  name_json="$(curl -sSf https://streaming.media.ccc.de/streams/v2.json)"
				verbose "Stream api json:\n${name_json}" 4
  if [ "$(echo "${name_json}" | tr -d "[:blank:]")" = "[]" ]; then
    verbose "${yellow}No json for display names available${nc}"
	else
		# json not empty
		name_array="$(name_array "${name_json}")"
		if [ -z "${name_array-}" ]; then
			verbose "${yellow}No display names for active streams available${nc}"
		fi

	fi
  # Create playlist
  # Playlist header
  echo "#EXTM3U" > "${playlist}"
  echo "#EXT-X-VERSION:3" >> "${playlist}"
  # Repeat playlist names and servers and "#EXT-X-DISCONTINUITY"
	verbose "main (${LINENO}): Create playlist"
  for STREAM in ${STREAMS}
  do
		unset conference
		unset DISPLAY
		unset playlist_info
		if [ -n "${name_array-}" ]; then
			STREAM_POS="$(stream_pos "${STREAM}")"
			if [ "$(echo "${STREAM_POS}")" -gt 0 ]; then
				STREAM_POS=$((STREAM_POS + 1))
				DISPLAY="$(display "${STREAM_POS}")"
				conference="$(findconference "${STREAM_POS}")"
			fi
			if [ -n "${conference-}" ]; then
						verbose "main (${LINENO}): Conference found: ${conference}" 3
				playlist_info=${conference}" - "
			fi
			if [ -n "${DISPLAY-}" ]; then
						verbose "main (${LINENO}): Display found: ${DISPLAY}" 3
				playlist_info=${playlist_info}${DISPLAY}
			fi
			if [ -z "${playlist_info-}" ]; then
						verbose "main (${LINENO}): Playlist empty" 3
				playlist_info=${STREAM}
			else
				if [ -n "${name_ext-}" ]; then
						verbose "main (${LINENO}): Option -n - add stream: ${STREAM}" 3
					playlist_info=${playlist_info}" - "${STREAM}
				fi
			fi
		else
			playlist_info=${STREAM}
		fi
			# Write stream as info into playlist
      echo "#EXTINF:0,${playlist_info}" >> "${playlist}"
					verbose "main (${LINENO}): Add ${playlist_info} to playlist: $?" 3
			# Write server into playlist
			echo "${serverpath}${STREAM}${serversuffix}" >> "${playlist}"
					verbose "main (${LINENO}): Add ${serverpath}${STREAM} to playlist: $?" 3
      # Write playlist divider
      echo "#EXT-X-DISCONTINUITY" >> "${playlist}"
  done
  {
    # Set a picture as last, so mpv will not end
    echo "#EXTINF:0,end of list"
    echo "${progpath}voctocat.png"
    # End of playlist
    echo "#EXT-X-ENDLIST"
  } >> "${playlist}"
  verbose "main (${LINENO}): Playlist complete: $?"
fi

# Exit if set option '-x'
if [ -n "${exitscript-}" ]; then
  exit 0
fi

# That is really playing
# Check mpv options in README.md
mpv "${playlist}" \
  --fs \
  --no-ytdl \
  --msg-level=all=error,ffmpeg=fatal \
  --no-input-default-bindings \
  --input-conf=${progpath}input.conf \
  --load-scripts=no \
  --scripts=${progpath}keys.lua \
  --force-window=immediate \
  --keep-open=always \
  --idle=yes \
  --vd-lavc-show-all=yes \
  --no-initial-audio-sync \
  --audio-stream-silence=yes \
  --demuxer-cache-wait=no \
	--force-seekable=no \
	--image-display-duration=inf \
  --screenshot-format=png \
  --script-opts=osc-visibility=always,osc-seekbarstyle=knob \
  --osd-duration=5000 \
  --osd-msg1="room: 1 â€“ 0       audio: q, w, e - Native, Translated, Translated-2       video: y, x - HD, Slides" \
  --no-osd-bar \
  --osd-font-size=30 \
  --osd-spacing=1 \
  --osd-border-size=1 \
  --osd-margin-x=10 \
  --osd-margin-y=4

verbose "Exit"
exit 0
