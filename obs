#! /bin/sh
#
# Opens mpv with all active (currently streaming) voc streams in a playlist.
#
# With options you can try all existing servers,
# try all servers that will be, are and were active until given days or
# try all servers given in a valid playlist.
#
# MIT License
# Copyright (c) 2020 Conrad Zelck

# set e: exit if something fails; set u: exit if a variable is unset
set -eu

#######################################
### Globals
#######################################

unset FORCE_DATE PLAYLIST_FILE DEBUG SORT NAME_EXT EXIT PRINT_JSON
readonly SERVERPATH="http://live.ber.c3voc.de:7999/"
readonly RTMPPATH="rtmp://ingest.c3voc.de/stream/"
readonly RED='\033[0;31m'
readonly YELLOW='\033[0;33m'
readonly NC='\033[0m' # No Color
readonly UNDERLINED='\033[4m'
readonly PROGNAME="${0##*/}"
VERBOSITY=0
ALL=false
FORCE=false

#######################################
# DescriptionOfTheFunction.
# Globals:
#   ListOfGlobalVariablesUsedOrModified
# Arguments:
#   ArgumentsTaken
# Outputs:
#   OutputToSTDOUTorSTDERR
# Returns:
#   ReturnedvValuesOtherThenExitStatus
#######################################

#######################################
### Functions
#######################################

#######################################
# Print verbose messages (in red if DEBUG).
# Globals:
#   VERBOSITY
#   DEBUG
#   RED
#   NC
# Arguments:
#   level
# Outputs:
#   msg to STDERR
# Returns:
#   None
#######################################
verbose() {
	msg="${1}"
	level="${2:-1}" # default 1 if not given
	i=0
  # only level up to VERBOSITY
	if [ ${level} -le ${VERBOSITY} ]; then
    # print '=' for every level
		while [ ${i} -lt ${level} ]; do
      # colorize in debug mode
      if [ -n "${DEBUG-}" ]; then
        printf "${RED}=${NC}\n" >&2
      else
        printf "=" >&2
      fi
			i=$(( ${i} + 1 ))
		done
    # print verbose message (colorize in debug mode)
    if [ -n "${DEBUG-}" ]; then
  		echo "${RED}> ${msg}${NC}" >&2
    else
  		echo "> ${msg}" >&2
    fi
	fi
}

#######################################
# Show extracted shortcuts from input.conf.
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   shortcut to STDOUT
# Returns:
#   None
#######################################
keys()
{
  echo "Shortcuts:"
  # grep all lines start not with #
  grep '^[[:blank:]]*[^[:blank:]#]' input.conf
  verbose "grep shortcuts from 'input.conf': $?" 2
  exit 0
}

#######################################
# Convert stream api json to server array.
# Globals:
#   FORCE
#   FORCE_DATE
# Arguments:
#   api json in JSON
# Outputs:
#   (endsAt \t display \t stream [ \t display \t stream ]*\n?)* to STDOUT
# Returns:
#   result
#######################################
# Convert stream api json to server array - output: endsAt \t display \t stream [ \t display \t stream ]
server_array ()
{
  verbose "Create server array"
  # Catch endsAt, display (name of room) and stream of ervery stream event
  result="$(echo "$1" | grep -E "\"endsAt\": \"?.+\"?,|^\s{24}\"display\": \"?.+\"?,|\"stream\": \"?.+\"?,")"
  verbose "Grep 'endsAt, display, stream including values': $?" 2
  # Make one plain, clean line of them all
  result="$(echo "${result}" | awk '{$1=$1;print}')"
  verbose "Remove leading/trailing white spaces: $?" 2
  result="$(echo "${result}" | sed 's/,$//g')"
  verbose "Remove trailing commas: $?" 2
  result="$(echo "${result}" | tr '\n' '\t')"
  verbose "Replace all newlines with tabs: $?" 2
  # Make every stream event a single line
  result="$(echo "${result}" | sed 's/\"endsAt/\'$'\n\"endsAt/g')"
  verbose "Insert newlines before endsAt: $?" 2
  # Remove first empty line
  result="$(echo "${result}" | tail -n +2)"
  verbose "Remove first newline: $?" 2
  # Remove all keys from key:value
  result="$(echo "${result}" | sed 's/\"endsAt\": //g')"
  verbose "Remove 'endsAt': $?" 2
  result="$(echo "${result}" | sed 's/\"display\": //g')"
  verbose "Remove 'display': $?" 2
  result="$(echo "${result}" | sed 's/\"stream\": //g')"
  verbose "Remove 'stream': $?" 2
  result="$(echo "${result}" | sed 's/\"//g')"
  verbose "Remove all \": $?" 2
  result="$(echo "${result}" | awk -F '\t' '{print $0}')"
  # Return only stream events that are younger then FORCE_DATE
  if [ "${FORCE}" = true ]; then
    verbose "Forced date: ${FORCE_DATE}"
    result="$(echo "${result}" | awk -F '\t' -v force_date="${FORCE_DATE}" '$1>=force_date && $1!="null" {print $0}')"
    verbose "Strip server array to forced days"
  fi
  echo "${result}"
}

#######################################
# Returning only servers from server array.
# Globals:
#   None
# Arguments:
#   server array as given by server_array()
# Outputs:
#   (server \t?)*
# Returns:
#   result
#######################################
server_only ()
{
  # returns odd fields started at 3
  result="$(echo "$1" | awk -F '\t' '{s="";for (i=3;i<=NF;i+=2) {s=s?s FS $i:$i} print s}')"
  verbose "Shrink server array to servers only: $?" 2
  echo "${result}"
}


#######################################
# Returning servers sorted alphanumerical.
# Globals:
#   None
# Arguments:
#   servers as given by server_only()
# Outputs:
#   OutputToSTDOUTorSTDERR
# Returns:
#   ReturnedvValuesOtherThenExitStatus
#######################################
sort_alphanum ()
{
  # Padding numbers with zeros to make sort with leading characters work
  result="$(echo "$1" | awk '{ gsub(/([^[:digit:]]+|[[:digit:]]+)/,"&\t") ; printf("%s%05d\n", $1, $2)}')"
  verbose "Fill numbers with leading zeros: $?" 2
  result="$(echo "${result}" | sort -n)"
  verbose "Sort numerical: $?" 2
  # Split leading characters to remove padded zeros
  result="$(echo "${result}" | awk '{ gsub(/([^[:digit:]]+|[[:digit:]]+)/,"&\t") ; print  $1, $2}')"
  verbose "Split at beginning of number: $?" 2
  result="$(echo "${result}" | awk '{gsub ("^0*", "", $2); printf("%s%s\n", $1, $2)}')"
  verbose "Strip leading zeros and merge: $?" 2
  echo "${result}"
}

#######################################
# Cleanup on exit.
#   Delete current-playlist (if not EXIT).
# Globals:
#   PLAYLIST
#   EXIT
# Arguments:
#   None
# Outputs:
#   None
# Returns:
#   None
#######################################
cleanup ()
{
  verbose "Cleanup on exit" 3
  PLAYLIST="current-playlist.m3u8"
  if [ -e "${PLAYLIST}" ] && [ -z "${EXIT-}" ]; then
    rm "${PLAYLIST}"
    verbose "Delete 'current-playlist.m3u8': $?" 3
  fi
  exit 0
}

#######################################
# Prints the usage manual.
# Globals:
#   PROGNAME
#   UNDERLINED
#   NC
# Arguments:
#   None
# Outputs:
#   usage to SDTOUT
# Returns:
#   None
#######################################
manual()
{
  echo "Usage: ${PROGNAME} [-a | -d | -D | -f ${UNDERLINED}days${NC} | -h | -j | -k | -n | -p ${UNDERLINED}file${NC} | -s | -v | -x]"
  echo "       opens mpv with all active voc streams"
  echo "       -a all streams listed in complete-playlist.m3u8 are tried"
  echo "       -d debug mode: print commands and arguments while executed"
  echo "       -D debug mode: print script lines while read"
  echo "       -f force to open all planned, active and past streams"
  echo "          ${UNDERLINED}days${NC} to the past are mandatory (to omit set 0)"
  echo "       -h help shown"
  echo "       -j json export to disk"
  echo "       -k keys/shortcuts shown"
  echo "       -n name server with original extension"
  echo "       -p playlist ${UNDERLINED}file${NC} with servers in format m3u8"
  echo "       -s sort server list alphanumerical"
  echo "       -v verbosity increasing with ${UNDERLINED}v${NC}"
  echo "       -x exit before mpv, keeps current-playlist.m3u8"
  exit 0
}

#######################################
### Main
#######################################

# Check options
while getopts 'adDf:hjknp:svx' option 2>/dev/null; do
  case "${option}" in
    a ) ALL=true;;
    d ) set -x # print commands and arguments while executed
        DEBUG=true;;
    D ) set -v # print script lines while read
        DEBUG=true;;
    f ) case ${OPTARG} in
          *[!0-9]* ) printf "%b\n" "${YELLOW}Warning: illegal option ${OPTARG} (no number)${NC}" 1>&2
                    exit 1;;
          * ) FORCE_DATE="$(date -v-${OPTARG}d -u +"%Y-%m-%dT%H:%M:%S+0000")"
             FORCE=true;;
        esac;;
    h ) manual;;
    j ) PRINT_JSON=true;;
    k ) keys;;
    n ) NAME_EXT=true;;
    p ) PLAYLIST_FILE="${OPTARG}";;
    s ) SORT=true;;
    v ) VERBOSITY=$(( ${VERBOSITY} + 1 ));;
    x ) EXIT=true;;
    * ) if [ $1 != "-?" ]; then
          curropt=$(( ${OPTIND} - 1 ))
          eval "curropt=\$${curropt}"
          printf "%b\n" "${YELLOW}Warning: illegal option ${curropt}${NC}" 1>&2
        fi
        manual;;
  esac
done
verbose "${YELLOW}Note: number after colon usually represents commands exit code${NC}"
verbose "Level of verbosity: ${VERBOSITY}"

# Exit handler
trap cleanup 0 1 2 3 6

# Check if mpv is existing
if ! [ -x "$(command -v mpv)" ]; then
  printf "%b\n" "${RED}Error: mpv does not exist, please install${NC}" 1>&2
  exit 1
fi

# Choose the playlist
# Option -a; all servers should be tried
if [ "${ALL}" = true ]; then
  # This playlist has all servers
  PLAYLIST="complete-playlist.m3u8"
  verbose "Used playlist: ${PLAYLIST}"
  if [ ! -f "${PLAYLIST}" ]; then
    printf "%b\n" "${YELLOW}Warning: playlist '${PLAYLIST}' with all servers does not exist${NC}" 1>&2
    exit 1
  fi
# Playlist given with option -p
elif [ -n "${PLAYLIST_FILE-}" ]; then
  PLAYLIST="${PLAYLIST_FILE}"
  verbose "Used playlist: ${PLAYLIST}"
  if [ ! -f "${PLAYLIST}" ]; then
    printf "%b\n" "${YELLOW}Warning: playlist '${PLAYLIST}' does not exist${NC}" 1>&2
    exit 1
  fi
else
  # This playlist should have only servers found in
  # https://streaming.media.ccc.de/streams/v2.json
  PLAYLIST="current-playlist.m3u8"
  verbose "Used playlist: ${PLAYLIST}"

  # Read streams by api json
  verbose "Read stream api"
  if [ "${FORCE}" = true ]; then
    # with option forceopen=1 (shows all streams done, running and planned)
    verbose "With option forceopen=1: ${FORCE}" 2
    JSON="$(curl -sSf https://streaming.media.ccc.de/streams/v2.json?forceopen=1)"
    verbose "Curl json: $?" 2
  else
    # shows only running streams
    JSON="$(curl -sSf https://streaming.media.ccc.de/streams/v2.json)"
    verbose "Curl json: $?" 2
  fi
  verbose "Stream api json:\n${JSON}" 4

  # Export json to disk
  if [ -n "${PRINT_JSON-}" ]; then
    echo "${JSON}" > current.json
  fi

  # Exit if trimmed (all white spaces) $JSON is empty
  if [ "$(echo "${JSON}" | tr -d "[:blank:]")" = "[]" ] && [ "${ALL}" = false ]; then
    printf "%b\n" "${YELLOW}Warning: no active streams available${NC}" 1>&2
    exit 1
  fi

  # Find servers in $JSON including end date and room names
  SERVER_ARRAY="$(server_array "${JSON}")"
  verbose "Server array:\n${SERVER_ARRAY}" 4
  # Trim to servers only
  SERVER="$(server_only "${SERVER_ARRAY}")"
  SERVER="$(echo "${SERVER}" | tr '\t' '\n')"
  verbose "Newline separated server list: $?" 2
  # Shrink servers to unique ones
  SERVER="$(echo "${SERVER}" | awk '!a[$0]++')"
  verbose "Shrink to unique servers: $?" 2
  # Exit if no servers found
  if [ "${SERVER}" = "" ]; then
    printf "%b\n" "${YELLOW}Warning: no searched streams available${NC}" 1>&2
    exit 1
  fi
  # Sort servers alphanumerical
  if [ -n "${SORT-}" ]; then
    verbose "Sorting servers"
    SERVER="$(sort_alphanum "${SERVER}")"
  fi
  verbose "Extracted servers:\n${SERVER}" 3

  # Create playlist
  # Playlist header
  echo "#EXTM3U" > "${PLAYLIST}"
  echo "#EXT-X-VERSION:3" >> "${PLAYLIST}"
  # Repeat playlist names and servers and "#EXT-X-DISCONTINUITY"
  for STREAM in ${SERVER}
  do
      # Write servers name as info into playlist; if option '-n' add ($STREAM) the technical server name
      NAME="$(echo "${SERVER_ARRAY}" | awk -F '\t' -v stream="${STREAM}" '{ for (x=1;x<=NF;x++) if ($x==stream) {print $(x-1); exit} }')"
      if [ -n "${NAME_EXT-}" ]; then
        echo "#EXTINF:0,${NAME} (${STREAM})" >> "${PLAYLIST}"
      else
        echo "#EXTINF:0,${NAME}" >> "${PLAYLIST}"
      fi
      # If servers first letter is "q" write it as an rtmp server
      if [ "$(echo "${STREAM}" | head -c1)" = "q" ]; then
        echo "${RTMPPATH}${STREAM}" >> "${PLAYLIST}"
        verbose "Add ${RTMPPATH}${STREAM} to playlist: $?" 3
      # Write normal server with http into playlist
      else
        echo "${SERVERPATH}${STREAM}" >> "${PLAYLIST}"
        verbose "Add ${SERVERPATH}${STREAM} to playlist: $?" 3
      fi
      # Write playlist divider
      echo "#EXT-X-DISCONTINUITY" >> "${PLAYLIST}"
  done
  {
    # Set a picture as last, so mpv will not end
    echo "#EXTINF:0,end of list"
    echo "voctocat.png"
    # End of playlist
    echo "#EXT-X-ENDLIST"
  } >> "${PLAYLIST}"
  verbose "Playlist complete: $?"
fi

# Exit if set option '-x'
if [ -n "${EXIT-}" ]; then
  exit 0
fi

# That is really playing
# Check mpv options in README.md
mpv "${PLAYLIST}" \
  --fs \
  --no-ytdl \
  --msg-level=all=error,ffmpeg=fatal \
  --no-input-default-bindings \
  --config-dir=. \
  --load-scripts=no \
  --scripts=select-audio.lua:select-video.lua:select-venue.lua \
  --force-window=immediate \
  --keep-open=always \
  --idle=yes \
  --vd-lavc-show-all=yes \
  --no-initial-audio-sync \
  --audio-stream-silence=yes \
  --demuxer-cache-wait=no \
  --screenshot-format=png \
  --script-opts=osc-visibility=always \
  --osd-duration=5000 \
  --osd-msg1="room: 1 – 0       audio: q, w, e - Native, Translated, Translated-2       video: y, x - HD, Slides" \
  --no-osd-bar \
  --osd-font-size=30 \
  --osd-spacing=1 \
  --osd-border-size=1 \
  --osd-margin-x=10 \
  --osd-margin-y=4

verbose "Exit"
exit 0
